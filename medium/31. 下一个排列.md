# 题目分析

输入：一组整数排列，nums

输出：nums 的下一个排列，即下一个字典序更大的排列

# 思路分析

这里的重点在于找出字典序排列的规律，例如 1，2，3，4 的排列：

> 1 2 3 4
> 1 2 4 3
> 1 3 2 4
> 1 3 4 2
> 1 4 2 3

这样的排列有什么规律呢？

我们知道，当整体数值要变大的时候，某一位上的数肯定是要增加的，而且为了保证这个数是下一个字典序，那这个变化的数越靠后越好，总的来说，就是从后往前找到一个可以变大的数。

既然是要变大，那肯定是找到一位比自己大的数进行交换，并且，这个数不能在自己前面，否则交换完成后，整体反而变小了。

因此，我们的问题变成了两个：

- 从后往前，找到想要增加的数
- 从这位数往后，找到可以交换的数

继续分析下，这个可以变大的数需要符合什么特征呢？首先，我们看最大的数 4 3 2 1，它是降序的，也就是说，如果整个数组是降序的，是不存在更大的数的，因为每一位数都无法变得更大，它后面没有比它大的数了。

那实际上，我们是要找到某个数，它正好后面有比它大的数，也就是存在这样的 i，numsi 小于 numsj ，其中 j > i。

而又因为我们想要找到是从后往前的第一个，所以是找到第一个升序对，即 nums i < nums i+1。

这是因为，前面必然都是降序的， i+1 肯定是后面最大的。

接着是第二个问题，哪个数值得交换呢？

当我们找到了 i，接下来是看 i+1 到 n-1 之间可以拿哪个跟 i 交换，我们想要保证刚好是下一个的话，这里就拿刚好大于自己的数，而因为是降序的，所以可以从后往前找到第一个大于自己的数。

交换完成后，还没完，i 位相当于进行了进位，那为了保证最小，后面整个倒序的序列，要变成升序的序列，因为升序的是最小的。

所以，总结起来就是三个步骤

- 找到要交换的 i
- 找到刚好大于 numsi 的进行交换
- 反转 i 后面的数组。





对于任何序列，关于排列序列需要注意的是：如果输入序列按降序排列，则不可能有下一个更大的排列



